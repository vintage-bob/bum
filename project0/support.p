unit support;interface	uses		Traps;	procedure InitManagers;	function CanUseWaitNextEvent: Boolean;implementation{check if your IDE does this for you...}	procedure InitManagers;	begin		InitGraf(@thePort);		InitFonts;		FlushEvents(everyEvent, 0);		InitWindows;		InitMenus;		TEInit;		InitDialogs(nil);		InitCursor;	end;	function NumToolboxTraps: Integer;	begin		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			NumToolboxTraps := $200		else			NumToolboxTraps := $400;	end;	function GetTrapType (theTrap: Integer): TrapType;		const			TrapMask = $0800;	begin		if BAND(theTrap, TrapMask) > 0 then			GetTrapType := ToolTrap		else			GetTrapType := OSTrap;	end;	function TrapAvailable (theTrap: Integer): Boolean;		var			tType: TrapType;	begin		tType := GetTrapType(theTrap);		if tType = ToolTrap then			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= NumToolboxTraps then					theTrap := _Unimplemented;			end;		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	end;	function CanUseWaitNextEvent: Boolean;	begin		CanUseWaitNextEvent := TrapAvailable(_WaitNextEvent);	end;end.