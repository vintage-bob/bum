{$I-}program boilerplate;	uses		support;	const		fileMenuId = 1;		specsMenuId = 2;	var		useWaitNextEvent: BOOLEAN;		dialog: dialogPtr;	type		DialogItemRecord = packed record				data: Handle;				bounds: Rect;				itemType: Byte;				size: Byte;			end;		DialogItemRecords = record				count: INTEGER;				fields: array[0..3] of DialogItemRecord;			end;		DialogItemRecordsPtr = ^DialogItemRecords;		DialogItemRecordsHandle = ^DialogItemRecordsPtr;	procedure SetUpMenu;		var			fileMenu: menuHandle;			specsMenu: menuHandle;	begin		fileMenu := NewMenu(fileMenuId, 'File');		appendMenu(fileMenu, 'Quit/q');		specsMenu := NewMenu(specsMenuId, 'Specifications');		appendMenu(specsMenu, 'Rom');		InsertMenu(fileMenu, 0);		InsertMenu(specsMenu, 0);		drawMenuBar;	end;	procedure InitField (var ditl: DialogItemRecord; column: integer; row: integer);	begin		with ditl, bounds do			begin				data := nil;				top := 10 + 20 * row;				left := 10 + 120 * column;				bottom := top + 16;				right := left + 100;				itemType := statText;				size := 0;			end;	end;	procedure SetDialogItemText (dialog: dialogPtr; ix: integer; value: Str255);		var			itemType: INTEGER;			itemText: handle;			box: Rect;	begin		GetDitem(dialog, ix, itemType, itemText, box);		SetIText(itemText, value);	end;	procedure SetDialogItemValue (dialog: dialogPtr; ix: integer; value: integer);		var			str: Str255;	begin		NumToString(value, str);		SetDialogItemText(dialog, ix, str);	end;	procedure ShowSpecifications;		var			frame: Rect;			items: DialogItemRecordsHandle;			i, row, column: INTEGER;			rom, machine: INTEGER;	begin		SetRect(frame, 50, 50, 240, 110);		items := DialogItemRecordsHandle(NewHandle(SIZEOF(DialogItemRecords)));		with items^^ do			begin				count := 3;				for i := 0 to 3 do					InitField(fields[i], i div 2, i mod 2);			end;		dialog := NewDialog(nil, frame, '', true, dBoxProc, POINTER(-1), false, 1, Handle(items));		environs(rom, machine);		SetDialogItemText(dialog, 1, 'Machine');		SetDialogItemText(dialog, 2, 'Rom');		SetDialogItemValue(dialog, 3, machine);		SetDialogItemValue(dialog, 4, rom);	end;	function MenuCommand (mResult: LONGINT): BOOLEAN;		var			theItem: INTEGER;			theMenu: INTEGER;	begin		MenuCommand := false;		theItem := LoWord(mResult);		theMenu := HiWord(mResult);		case theMenu of			fileMenuId: 				MenuCommand := true;			specsMenuId: 				ShowSpecifications;		end;		HiliteMenu(0);	end;	function doEvent (myEvent: EventRecord): BOOLEAN;		var			theChar: CHAR;			whichWindow: windowPtr;	begin		doEvent := false;		case myEvent.what of			mousedown: 				case FindWindow(myEvent.where, whichWindow) of					inMenuBar: 						doEvent := MenuCommand(MenuSelect(myEvent.where));					inContent: 						if (dialog <> nil) then							begin								disposDialog(dialog);								dialog := nil;							end;				end;			keyDown, autoKey: 				begin					theChar := CHR(BitAnd(myEvent.message, charCodeMask));					if BitAnd(myEvent.modifiers, cmdKey) <> 0 then						doEvent := MenuCommand(MenuKey(theChar));				end;		end;	end;	procedure EventLoop;		var			event: EventRecord;			done: BOOLEAN;			eventReceived: BOOLEAN;	begin		useWaitNextEvent := CanUseWaitNextEvent;		done := FALSE;		repeat			if not useWaitNextEvent then				SystemTask;			if useWaitNextEvent then				eventReceived := WaitNextEvent(everyEvent, event, 6, nil)			else				eventReceived := GetNextEvent(everyEvent, event);			if eventReceived then				done := doEvent(event)		until done;	end;begin	InitManagers;	SetUpMenu;	EventLoop;end.