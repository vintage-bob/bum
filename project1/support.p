unit support;interface	uses		Traps;	procedure InitManagers;	function CanUseWaitNextEvent: Boolean;implementation{If you use this routine, you might need to use a compiler directive to disable init glue provided by the IDE}	procedure InitManagers;	begin		InitGraf(@thePort);		InitFonts;		FlushEvents(everyEvent, 0);		InitWindows;		InitMenus;		TEInit;		InitDialogs(nil);		InitCursor;	end;	function NumToolboxTraps: Integer;	begin		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			NumToolboxTraps := $200		else			NumToolboxTraps := $400;	end;	function GetTrapType (theTrap: Integer): TrapType;		const			TrapMask = $0800;	begin		if BAND(theTrap, TrapMask) > 0 then			GetTrapType := ToolTrap		else			GetTrapType := OSTrap;	end;	function TrapAvailable (theTrap: Integer): Boolean;		var			tType: TrapType;	begin		tType := GetTrapType(theTrap);		if tType = ToolTrap then			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= NumToolboxTraps then					theTrap := _Unimplemented;			end;		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	end;	function Minimal128KRom: BOOLEAN;		var			rom: INTEGER;			machine: INTEGER;	begin		environs(rom, machine);		Minimal128KRom := rom >= $75;	end;	function CanUseWaitNextEvent: Boolean;	begin		if not Minimal128KRom then			CanUseWaitNextEvent := false		else			CanUseWaitNextEvent := TrapAvailable(_WaitNextEvent);	end;end.